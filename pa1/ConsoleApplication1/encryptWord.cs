//    Author: Andrew Kramer
// File name: encryptWord.cs
//      Date: 4/30/2016

// Description goes here

/*
  Assumptions:
  - On/Off data member
    - Makes object unable to encrypt words or accept guesses when set to off
    - Is set to off when a correct guess is made
    - Is set to off when maximum number of guesses is reached
  - Decoding is defined as guessing the correct shift value
  - Guessing statistics are only displayed when the user makes a correct guess
    or reaches the guess limit
  - Statistics cannot be displayed by the user
  - Resetting
    - Clears the guess history
    - Sets the object to on
    - Generates a new shift value
  - Only alphabetic characters are encoded, nonalphabetic characters 
    are left unchanged
  - Shift value is always between 0 and 26 exclusive
  - Shift value is generated by a Random object passed to the constructor
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ConsoleApplication1
{
  public class encryptWord
  {
    private int shiftValue; // amount by which encrypted words are shifted
    private int maxGuesses; // max number of guesses allowed
    private List<int> guessHistory; // record of guessed shift values
    private bool isOn;
    private Random r;
    private const int defaultGuesses = 10;
    private const string validChars = "abcdefghijklmnopqrstuvwxyz /t/n";

    public encryptWord(Random r)
    {
      this.r = r;
      shiftValue = this.r.Next(0, 26);
      Console.WriteLine("Shift value = " + shiftValue);
      maxGuesses = defaultGuesses;
      guessHistory = new List<int>();
      isOn = true;
    }

    public encryptWord(Random r, int maxGuesses)
    {
      this.r = r;
      shiftValue = this.r.Next(0, 26);
      this.maxGuesses = maxGuesses;
      guessHistory = new List<int>();
      isOn = true;
    }

    // precondition: accepts a string as a parameter
    // postcondition: returns an encoded string
    // only alphabetic characters are encoded
    // throws an exception if string length is less than 4
    // throws an exception if the object is off
    public string encrypt(string word)
    {
      if (!isOn)
        throw new Exception("Object is off, reset to try again.");
      if (word.Length < 4)
        throw new Exception("Given string must be 4 chars long or more.");
      string result = "";
      for (int i = 0; i < word.Length; i++)
      {
        int nextChar = (int)word[i];
        if (word[i] >= 65 && word[i] <= 122) // only shift if char is alphabetic
        {
          nextChar += shiftValue;
        }
        // if current char is upper case
        if (word[i] <= 90 && nextChar > 90)
        {
          nextChar = ((nextChar - 65) % 26) + 65;
        }
        // if current char is lower case
        if (word[i] >= 97 && nextChar > 122)
        {
          nextChar = ((nextChar - 97) % 26) + 97;
        }
        result += (char)nextChar;
      }
      return result;
    }

    // precondition: accepts an int as a parameter
    // postcondition: prints success message and guess stats and turns object
    // off if int is equal to shiftValue, prints failure message if not 
    // if max number of guesses is reached prints guess stats and turns object
    // off throws an exception if the object is off
    public void guess(int guess)
    {
      if (!isOn)
        throw new Exception("Object is off, reset to try again.");
      if (guess == shiftValue)
      {
        Console.WriteLine("Your guess was correct!");
        guessHistory.Add(guess);
        printStats();
        isOn = false;
        Console.WriteLine();
        Console.WriteLine("Reset to try again");
      }
      else
      {
        guessHistory.Add(guess);
        if (guess < shiftValue)
          Console.WriteLine("Sorry, your guess was too low.");
        else
          Console.WriteLine("Sorry, your guess was too high.");
        if (guessHistory.Count() == maxGuesses)
        {
          Console.WriteLine("You have reached the maximum number of guesses.");
          Console.WriteLine();
          Console.WriteLine("Reset to try again.");
          isOn = false;
          printStats();
        }
      }
    }

    // postconditions: turns object on, clears guess history, and generates
    // a new shift value
    public void reset()
    {
      Console.WriteLine("Shift value is reset and guess"
                        + "history has been cleared.");
      shiftValue = r.Next(0, 26);
      guessHistory.Clear();
      isOn = true;
    }

    // postconditions: returns true if object is on, false if not
    public bool getIsOn()
    {
      return isOn;
    }

    // postconditions: prints guess statistics to the console
    private void printStats()
    {
      int min = int.MaxValue, max = 0;
      double mean = 0.0;
      foreach (int n in guessHistory)
      {
        if (n < min) min = n;
        if (n > max) max = n;
        mean += (double)n;
      }
      mean /= (double)guessHistory.Count();
      Console.WriteLine("Guess statistics:");
      Console.WriteLine("Minimum  -  " + min);
      Console.WriteLine("Maximum  -  " + max);
      Console.WriteLine("Mean     -  " + String.Format("{0:0.00}", mean));
    }
  }
}
